# 테스트 주도 개발 스터디 (Android)
> 켄트 백의 Test-Driven Development by Example(이하 TDD)을 서적의 예제를 테스트해보는 안드로이드 프로젝트입니다.
>
> 서적의 일반 JVM의 예제와 동일하게 구현합니다. 다만 언어는 Kotlin으로 작성합니다.



### 테스트 주도 개발

> 작동하는 깔끔한 코드를 작성하는 것이 TDD의 궁극적인 목표입니다.
>
> TDD는 작동하는이 우선이고 깔끔한이 나중에 진행하는 흐름입니다.
>
> 이것의 반대는 Architecture-Driven Development입니다.



### 요약

#### 1장 - 다중 통화를 지원하는 Money 객체

* TDD의 흐름
  * 작은 테슽를 하나 추가한다.
  * 모든 테스트를 실행해서 테스트가 실패하는 것을 확인한다.
  * 조금 수정한다.
  * 모든 테스트를 실행해서 테스트가 성공하는 것을 확인한다.
  * 중복을 제거하기 위해 리팩토링을 한다.

#### 2장 - 타락한 객체

* 테스트 케이스가 성공하도록 만든다.
  * 가짜로 구현하기 (스텁 구현)
    * 상수를 반환하게 만들고 진짜 코든를 얻을 때까지 단계적으로 상수를 변수로 바꾸어 간다.
  * 명백한 구현 사용하기
    * 실제 구현을 입력한다.

#### 3장 - 모두를 위한 평등

* 값 객체
  * equals() and hashCode()
* 삼각측량 전략
  * 두개 이상의 예제를 두어 코드를 일반화 할 수 있다.
  * 5 == 5는 테스트를 통과하기 위해서 상수를 사용할 수 있다.
  * 5 == 5와 5 == 6 모두를 만족하려면 상수로는 불가능하다. 여기서 일반화가 필요하다.
  * 테스트를 작성할 때 첫번째는 상수로, 두번째 처럼 좀더 일반적인 해가 필요로 할 때 일반화 한다.
* 삼각측량 전략이 필요할 때
  * 코드와 테스트 사이의 중복을 제거하고 일반적인 해법을 구할 방법이 보이면 그냥 그대로 구현한다.
  * 하지만 설계를 어떻게 할지 떠오르지 않을 때면, 삼각측량은 문제를 조금 다른 방향에서 볼 기회를 준다.
* 여기서의 흐름
  * 우리의 디자인 패턴이 하나의 또 다른 오퍼레이션을 암시한다는 걸 알아챘다. (값 객체로 동작해야되는 것을)
  * 해당 오퍼레이션을 테스트했다.
  * 해당 오퍼레이션을 간단히 구현했다.
  * 곧장 리팩토링하는 대신 테스트를 조금 더 했다.
  * 두 경우를 모두 수용할 수 있도록 리팩토링했다.

#### 4장 - 프라이버시

* 3장에서 동치성(Equality)를 해결했다.
* 동치성을 이용하여 테스트코드에서의 결합도를 낮출 수 있다. (직접 멤버 변수인 amount를 비교하는 것)
* 여기서의 흐름
  * 오직 테스트를 향상시키기 위해서만 개발된 기능을 사용했다.
  * 두 테스트가 동시에 실패하면 망한다는 점을 인식했다.
  * 위험 요소가 있음에도 계속 진행했다.
  * 테스트와 코드 사이의 결합도를 낮추기 위해, 테스트 하는 객체의 새기능을 사용했다.

#### 5장 - 솔직히 말하자면

> 테스트 케이스:
>
> $5 + 10CHF = $10 (환율이 2:1일 경우)

* 위 테스트에 대한 접근은 어떻게 하는게 좋을까?
  * Franc라는 화폐를 표현할 수 있는 객체가 필요하다
  * 앞서 만든 Dollar를 이용하면 빠르게 테스트를 수행해 볼 수 있을거 같다.
  * 그래서 Dollar를 복사해서 Franc를 만든다. (여기서 복붙이을 하는 것을 보고 장난해? 라고 생각하면 진정해라)
* 우리가 하고자 하는 단계에 대한 포인트 (**여기서 앞의 4단계는 빨리 진행해야 한다**, 그래서 복붙을...)
  * **테스트 작성**
  * **컴피일되게 하기**
  * **실패하는지 확인하기 위해 실행**
  * **실행하게 만듦**
  * 중복제거
* 여기서의 흐름
  * 큰 테스트는 공략할 수 없다. 그래서 진전을 나타낼 수 있는 자그마한 테스트를 만들었다.
  * 뻔뻔스럽게도 중복을 만들고 조금 고쳐서 테스트를 작성했다.
  * 설상가상으로 모델 코드까지 도매금으로 복사하고 수정해서 테스트를 수정했다. ㅋㅋ
  * **죽복이 사라지기 전에는 집에 가지 않겠다고 약속했다.**

#### 6장 - 돌아온 '모두를 위한 평등'

> 테스트 케이스:
>
> 공용 equals

* 우리가 저지른 죄

  * 무언가 하기위해서 우리는 죄를 지었다.
  * 새로운 테스트 케이스를 하나 작동하게 만들었다.
  * 하지만 테스트를 빨리 통과하기 위해서 코드를 복붙했다.(으아아악!!!)
  * 그래서 청소를 해야된다.

* 청소 방법

  * 하나의 클래스가 다른 클래스를 상속하게 만든다. (실패하게 된다)
  * 두개의 클래스의 공통 클래스를 만들고 각각 상속하게 한다. (시간이 걸렸지만 성공하게 된다)

* 상위 클래스.. 그이름 머니

  ```kotlin
  class Money
  ...
  class Dollar : Money()
  ...
  class Franc: Money()
  ...
  ```

* 여기서의 흐름

  * Dollar의 amount를 Money가 protected val amount: Int로 옮긴다.
  * 그리고 Dollar는 Money를 상속한다.
  * 그리고 Dollar의 equals에서 cast를 변경하고 Money로 코드를 변경한다.
  * Dollar의 equals를 Money로 옮겨가도 문제가 없게 되었다. 이제 옮기자.
  * 각각을 진행 할 때 테스트를 돌려보고 성공하는지를 본다.
  * Franc도 동일하게 진행한다.
  * **이러한 리팩토링의 과정에서 테스트가  통과하는지 매번 실행을 해본다**

#### 7장 - 사과와 오렌지

> Dollar와 Franc 비교하기

* Dollar와 Franc을 비교하면 어떻게 될까?

  ```kotlin
  assertThat(Franc(5) == Dollar(5)).isFalse()
  ```

* 결과는 실패한다. 이옹. Dollar와 Franc이 같다고 한다. 다른건데...

* 그래서 class까지 비교하도록 수정한다.

* 여기서의 흐름

  * 우릴 괴롭히던 결함을 끄집어내서 테스트에 담아냈다 (Dollar와 Franc이 같지 않다는 테스트..)
  * 완벽하진 않지만 그럭저럭 봐줄 만한 방법 (getClass())으로 테스트를 통과하게 만들었다.
  * 더 많은 동기가 있기 전에는 더 많은 설계를 도입하지 않기로 했다.

#### 8장 - 객체 만들기

> Dollar/Franc의 중복

* 두 구현코드에서 times() 메소드는 거의 같다.

* 중복을 제거하자.

* 각각의 구현코드에서 times를 제거하고 Money에서 일을 하게 만들고 싶지만 한번에 많은 단계를 밟는 것은 TDD를 효과적으로 보여주기에 적절하지 않은 것 같다.

* 하위 클래스에 대한 직접적인 참조가 적어진다면 하위 클래스를 제거하기 위해 더 다가섰다고 할 수 있겠다.

* 하지만 Money에는 times()를 직접 구현하지 않았기에 Money를 추상클래스로 times()를 추상 메소드로 한다.

  ```kotlin
  abstract class Money
  abstract fun times(multiplier: Int): Money
  ```

* 이렇게 함으로서 테스트 코드에서 하위 클래스의 참조를 줄일 수 있다.

* 여기서의 흐름

  * 동일한 메서드(times)의 두 변이형 메서드 서명부를 통일시킴으로써 중복 제거를 향해 한 단계 더 진전했다.
  * 최소한 메서드 선언부만이라도 공통 상위 클래스(superclass)로 옮겼다.
  * 팩토리 메서드를 도입하여 테스트 코드에서 콘크리트 하위 클래스의 존재 사실을 분리해냈다.
  * 하위 클래스가 사라지면 몇몇 테스트는 불필요한 여분의 것이 된다는 것을 인색했다. 하지만 일단 그냥 뒀다.

#### 9장 - 우리가 사는 시간

> 불필요한 하위 클래스를 제거하는 데 도움이 될까? 통화 개념을 도입해보자
>
> 통화 개념을 구현하려면 어떻게 해야될까? 아차 실수.. 통화 개념을 테스트 하려면 어떻게 테스트하길 원하는가?
>
> 간단하게 문자열로 대신해서 해보자

```kotlin
abstract class Money(
    protected val amount: Int,
    protected val currency: String
) {
    fun currency(): String = currency
}
```

Dollar/Franc의 times에서 각각의 생성자를 호출하는 부분이 있다. 이를 Money의 팩토리 함수로 바꿔보자

```kotlin
class Dollar: Money {
    fun times(multiplier: Int) {
        return Dollar(amount * multiplier)
    }
    ..를 아래 처럼 변경해보자
    fun times(multiplier: Int) {
        return Money.dollar(amount * amultiplier)
    }
}
```

Franc도 마찬가지다.

* 여기서의 흐름
  * 큰 설계 아이디어를 다루다가 조금 곤경에 빠졌다. 그래서 좀 전에 주목했던 더 작은 작업을 수행했다.
  * 다른 부분들을 호출자(팩토리 메서드)로 옮김으로써 두 생성자를 일치시켰다.
  * **중요** times()가 팩토리 메서드를 사용하도록 만들기 위해 리팩토링을 잠시 중단했다.
  * 비슷한 리팩토링(Franc에서 했던것을 Dollar)을 한번의 큰 단계로 처리했다.
  * 동일한 생성자들을 상위 클래스로 올렸다.





