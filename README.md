# 테스트 주도 개발 스터디 (Android)
> 켄트 백의 Test-Driven Development by Example(이하 TDD)을 서적의 예제를 테스트해보는 안드로이드 프로젝트입니다.
>
> 서적의 일반 JVM의 예제와 동일하게 구현합니다. 다만 언어는 Kotlin으로 작성합니다.



### 테스트 주도 개발

> 작동하는 깔끔한 코드를 작성하는 것이 TDD의 궁극적인 목표입니다.
>
> TDD는 작동하는이 우선이고 깔끔한이 나중에 진행하는 흐름입니다.
>
> 이것의 반대는 Architecture-Driven Development입니다.



### 요약

#### 1장 - 다중 통화를 지원하는 Money 객체

* TDD의 흐름
  * 작은 테슽를 하나 추가한다.
  * 모든 테스트를 실행해서 테스트가 실패하는 것을 확인한다.
  * 조금 수정한다.
  * 모든 테스트를 실행해서 테스트가 성공하는 것을 확인한다.
  * 중복을 제거하기 위해 리팩토링을 한다.

#### 2장 - 타락한 객체

* 테스트 케이스가 성공하도록 만든다.
  * 가짜로 구현하기 (스텁 구현)
    * 상수를 반환하게 만들고 진짜 코든를 얻을 때까지 단계적으로 상수를 변수로 바꾸어 간다.
  * 명백한 구현 사용하기
    * 실제 구현을 입력한다.

#### 3장 - 모두를 위한 평등

* 값 객체
  * equals() and hashCode()
* 삼각측량 전략
  * 두개 이상의 예제를 두어 코드를 일반화 할 수 있다.
  * 5 == 5는 테스트를 통과하기 위해서 상수를 사용할 수 있다.
  * 5 == 5와 5 == 6 모두를 만족하려면 상수로는 불가능하다. 여기서 일반화가 필요하다.
  * 테스트를 작성할 때 첫번째는 상수로, 두번째 처럼 좀더 일반적인 해가 필요로 할 때 일반화 한다.
* 삼각측량 전략이 필요할 때
  * 코드와 테스트 사이의 중복을 제거하고 일반적인 해법을 구할 방법이 보이면 그냥 그대로 구현한다.
  * 하지만 설계를 어떻게 할지 떠오르지 않을 때면, 삼각측량은 문제를 조금 다른 방향에서 볼 기회를 준다.
* 여기서의 흐름
  * 우리의 디자인 패턴이 하나의 또 다른 오퍼레이션을 암시한다는 걸 알아챘다. (값 객체로 동작해야되는 것을)
  * 해당 오퍼레이션을 테스트했다.
  * 해당 오퍼레이션을 간단히 구현했다.
  * 곧장 리팩토링하는 대신 테스트를 조금 더 했다.
  * 두 경우를 모두 수용할 수 있도록 리팩토링했다.

#### 4장 - 프라이버시

* 3장에서 동치성(Equality)를 해결했다.
* 동치성을 이용하여 테스트코드에서의 결합도를 낮출 수 있다. (직접 멤버 변수인 amount를 비교하는 것)
* 여기서의 흐름
  * 오직 테스트를 향상시키기 위해서만 개발된 기능을 사용했다.
  * 두 테스트가 동시에 실패하면 망한다는 점을 인식했다.
  * 위험 요소가 있음에도 계속 진행했다.
  * 테스트와 코드 사이의 결합도를 낮추기 위해, 테스트 하는 객체의 새기능을 사용했다.

#### 5장 - 솔직히 말하자면

> 테스트 케이스:
>
> $5 + 10CHF = $10 (환율이 2:1일 경우)

* 위 테스트에 대한 접근은 어떻게 하는게 좋을까?
  * Franc라는 화폐를 표현할 수 있는 객체가 필요하다
  * 앞서 만든 Dollar를 이용하면 빠르게 테스트를 수행해 볼 수 있을거 같다.
  * 그래서 Dollar를 복사해서 Franc를 만든다. (여기서 복붙이을 하는 것을 보고 장난해? 라고 생각하면 진정해라)
* 우리가 하고자 하는 단계에 대한 포인트 (**여기서 앞의 4단계는 빨리 진행해야 한다**, 그래서 복붙을...)
  * **테스트 작성**
  * **컴피일되게 하기**
  * **실패하는지 확인하기 위해 실행**
  * **실행하게 만듦**
  * 중복제거
* 여기서의 흐름
  * 큰 테스트는 공략할 수 없다. 그래서 진전을 나타낼 수 있는 자그마한 테스트를 만들었다.
  * 뻔뻔스럽게도 중복을 만들고 조금 고쳐서 테스트를 작성했다.
  * 설상가상으로 모델 코드까지 도매금으로 복사하고 수정해서 테스트를 수정했다. ㅋㅋ
  * **죽복이 사라지기 전에는 집에 가지 않겠다고 약속했다.**

#### 6장 - 돌아온 '모두를 위한 평등'

> 테스트 케이스:
>
> 공용 equals

* 우리가 저지른 죄

  * 무언가 하기위해서 우리는 죄를 지었다.
  * 새로운 테스트 케이스를 하나 작동하게 만들었다.
  * 하지만 테스트를 빨리 통과하기 위해서 코드를 복붙했다.(으아아악!!!)
  * 그래서 청소를 해야된다.

* 청소 방법

  * 하나의 클래스가 다른 클래스를 상속하게 만든다. (실패하게 된다)
  * 두개의 클래스의 공통 클래스를 만들고 각각 상속하게 한다. (시간이 걸렸지만 성공하게 된다)

* 상위 클래스.. 그이름 머니

  ```kotlin
  class Money
  ...
  class Dollar : Money()
  ...
  class Franc: Money()
  ...
  ```

* 이장의 흐름

  * Dollar의 amount를 Money가 protected val amount: Int로 옮긴다.
  * 그리고 Dollar는 Money를 상속한다.
  * 그리고 Dollar의 equals에서 cast를 변경하고 Money로 코드를 변경한다.
  * Dollar의 equals를 Money로 옮겨가도 문제가 없게 되었다. 이제 옮기자.
  * 각각을 진행 할 때 테스트를 돌려보고 성공하는지를 본다.
  * Franc도 동일하게 진행한다.
  * **이러한 리팩토링의 과정에서 테스트가  통과하는지 매번 실행을 해본다**



